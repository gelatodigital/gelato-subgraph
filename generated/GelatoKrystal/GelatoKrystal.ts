// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class LogExecSuccess extends ethereum.Event {
  get params(): LogExecSuccess__Params {
    return new LogExecSuccess__Params(this);
  }
}

export class LogExecSuccess__Params {
  _event: LogExecSuccess;

  constructor(event: LogExecSuccess) {
    this._event = event;
  }

  get taskId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get executor(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LogTaskCanceled extends ethereum.Event {
  get params(): LogTaskCanceled__Params {
    return new LogTaskCanceled__Params(this);
  }
}

export class LogTaskCanceled__Params {
  _event: LogTaskCanceled;

  constructor(event: LogTaskCanceled) {
    this._event = event;
  }

  get taskId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get order(): LogTaskCanceledOrderStruct {
    return this._event.parameters[1].value.toTuple() as LogTaskCanceledOrderStruct;
  }
}

export class LogTaskCanceledOrderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class LogTaskRemoved extends ethereum.Event {
  get params(): LogTaskRemoved__Params {
    return new LogTaskRemoved__Params(this);
  }
}

export class LogTaskRemoved__Params {
  _event: LogTaskRemoved;

  constructor(event: LogTaskRemoved) {
    this._event = event;
  }

  get remover(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get taskHash(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class LogTaskStored extends ethereum.Event {
  get params(): LogTaskStored__Params {
    return new LogTaskStored__Params(this);
  }
}

export class LogTaskStored__Params {
  _event: LogTaskStored;

  constructor(event: LogTaskStored) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get user(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get hash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get payload(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }
}

export class LogTaskSubmitted extends ethereum.Event {
  get params(): LogTaskSubmitted__Params {
    return new LogTaskSubmitted__Params(this);
  }
}

export class LogTaskSubmitted__Params {
  _event: LogTaskSubmitted;

  constructor(event: LogTaskSubmitted) {
    this._event = event;
  }

  get taskId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get order(): LogTaskSubmittedOrderStruct {
    return this._event.parameters[1].value.toTuple() as LogTaskSubmittedOrderStruct;
  }
}

export class LogTaskSubmittedOrderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class GelatoKrystal__getMinReturnInput_orderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class GelatoKrystal__isTaskSubmittedInput_orderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class GelatoKrystal extends ethereum.SmartContract {
  static bind(address: Address): GelatoKrystal {
    return new GelatoKrystal("GelatoKrystal", address);
  }

  HINT(): Bytes {
    let result = super.call("HINT", "HINT():(bytes)", []);

    return result[0].toBytes();
  }

  try_HINT(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("HINT", "HINT():(bytes)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  PLATFORM_FEE_BPS(): BigInt {
    let result = super.call(
      "PLATFORM_FEE_BPS",
      "PLATFORM_FEE_BPS():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_PLATFORM_FEE_BPS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "PLATFORM_FEE_BPS",
      "PLATFORM_FEE_BPS():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  currentTaskId(): BigInt {
    let result = super.call("currentTaskId", "currentTaskId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_currentTaskId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "currentTaskId",
      "currentTaskId():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  executor(): Address {
    let result = super.call("executor", "executor():(address)", []);

    return result[0].toAddress();
  }

  try_executor(): ethereum.CallResult<Address> {
    let result = super.tryCall("executor", "executor():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  gelatoAS(): Address {
    let result = super.call("gelatoAS", "gelatoAS():(address)", []);

    return result[0].toAddress();
  }

  try_gelatoAS(): ethereum.CallResult<Address> {
    let result = super.tryCall("gelatoAS", "gelatoAS():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getGasPrice(): BigInt {
    let result = super.call("getGasPrice", "getGasPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getGasPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getGasPrice", "getGasPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMinReturn(_order: GelatoKrystal__getMinReturnInput_orderStruct): BigInt {
    let result = super.call(
      "getMinReturn",
      "getMinReturn((address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)):(uint256)",
      [ethereum.Value.fromTuple(_order)]
    );

    return result[0].toBigInt();
  }

  try_getMinReturn(
    _order: GelatoKrystal__getMinReturnInput_orderStruct
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMinReturn",
      "getMinReturn((address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)):(uint256)",
      [ethereum.Value.fromTuple(_order)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  hashTask(_bytesBlob: Bytes, _taskId: BigInt): Bytes {
    let result = super.call("hashTask", "hashTask(bytes,uint256):(bytes32)", [
      ethereum.Value.fromBytes(_bytesBlob),
      ethereum.Value.fromUnsignedBigInt(_taskId)
    ]);

    return result[0].toBytes();
  }

  try_hashTask(_bytesBlob: Bytes, _taskId: BigInt): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "hashTask",
      "hashTask(bytes,uint256):(bytes32)",
      [
        ethereum.Value.fromBytes(_bytesBlob),
        ethereum.Value.fromUnsignedBigInt(_taskId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  isTaskSubmitted(
    _order: GelatoKrystal__isTaskSubmittedInput_orderStruct,
    _id: BigInt
  ): boolean {
    let result = super.call(
      "isTaskSubmitted",
      "isTaskSubmitted((address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256),uint256):(bool)",
      [ethereum.Value.fromTuple(_order), ethereum.Value.fromUnsignedBigInt(_id)]
    );

    return result[0].toBoolean();
  }

  try_isTaskSubmitted(
    _order: GelatoKrystal__isTaskSubmittedInput_orderStruct,
    _id: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isTaskSubmitted",
      "isTaskSubmitted((address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256),uint256):(bool)",
      [ethereum.Value.fromTuple(_order), ethereum.Value.fromUnsignedBigInt(_id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  platformWallet(): Address {
    let result = super.call("platformWallet", "platformWallet():(address)", []);

    return result[0].toAddress();
  }

  try_platformWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "platformWallet",
      "platformWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  serviceRegistry(): Address {
    let result = super.call(
      "serviceRegistry",
      "serviceRegistry():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_serviceRegistry(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "serviceRegistry",
      "serviceRegistry():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  smartWalletSwap(): Address {
    let result = super.call(
      "smartWalletSwap",
      "smartWalletSwap():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_smartWalletSwap(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "smartWalletSwap",
      "smartWalletSwap():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  sushiRouterV2(): Address {
    let result = super.call("sushiRouterV2", "sushiRouterV2():(address)", []);

    return result[0].toAddress();
  }

  try_sushiRouterV2(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "sushiRouterV2",
      "sushiRouterV2():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  taskId(): BigInt {
    let result = super.call("taskId", "taskId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_taskId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("taskId", "taskId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  taskOwner(param0: Bytes): Address {
    let result = super.call("taskOwner", "taskOwner(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_taskOwner(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("taskOwner", "taskOwner(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  uniRouterV2(): Address {
    let result = super.call("uniRouterV2", "uniRouterV2():(address)", []);

    return result[0].toAddress();
  }

  try_uniRouterV2(): ethereum.CallResult<Address> {
    let result = super.tryCall("uniRouterV2", "uniRouterV2():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  verifyTask(_bytesBlob: Bytes, _id: BigInt, _user: Address): boolean {
    let result = super.call(
      "verifyTask",
      "verifyTask(bytes,uint256,address):(bool)",
      [
        ethereum.Value.fromBytes(_bytesBlob),
        ethereum.Value.fromUnsignedBigInt(_id),
        ethereum.Value.fromAddress(_user)
      ]
    );

    return result[0].toBoolean();
  }

  try_verifyTask(
    _bytesBlob: Bytes,
    _id: BigInt,
    _user: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "verifyTask",
      "verifyTask(bytes,uint256,address):(bool)",
      [
        ethereum.Value.fromBytes(_bytesBlob),
        ethereum.Value.fromUnsignedBigInt(_id),
        ethereum.Value.fromAddress(_user)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _smartWalletSwap(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _uniRouterV2(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _sushiRouterV2(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _platformWallet(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get gelatoAddressStorage(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class CancelCall extends ethereum.Call {
  get inputs(): CancelCall__Inputs {
    return new CancelCall__Inputs(this);
  }

  get outputs(): CancelCall__Outputs {
    return new CancelCall__Outputs(this);
  }
}

export class CancelCall__Inputs {
  _call: CancelCall;

  constructor(call: CancelCall) {
    this._call = call;
  }

  get _order(): CancelCall_orderStruct {
    return this._call.inputValues[0].value.toTuple() as CancelCall_orderStruct;
  }

  get _id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class CancelCall__Outputs {
  _call: CancelCall;

  constructor(call: CancelCall) {
    this._call = call;
  }
}

export class CancelCall_orderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class ExecKyberCall extends ethereum.Call {
  get inputs(): ExecKyberCall__Inputs {
    return new ExecKyberCall__Inputs(this);
  }

  get outputs(): ExecKyberCall__Outputs {
    return new ExecKyberCall__Outputs(this);
  }
}

export class ExecKyberCall__Inputs {
  _call: ExecKyberCall;

  constructor(call: ExecKyberCall) {
    this._call = call;
  }

  get _order(): ExecKyberCall_orderStruct {
    return this._call.inputValues[0].value.toTuple() as ExecKyberCall_orderStruct;
  }

  get _id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ExecKyberCall__Outputs {
  _call: ExecKyberCall;

  constructor(call: ExecKyberCall) {
    this._call = call;
  }
}

export class ExecKyberCall_orderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class ExecUniOrSushiCall extends ethereum.Call {
  get inputs(): ExecUniOrSushiCall__Inputs {
    return new ExecUniOrSushiCall__Inputs(this);
  }

  get outputs(): ExecUniOrSushiCall__Outputs {
    return new ExecUniOrSushiCall__Outputs(this);
  }
}

export class ExecUniOrSushiCall__Inputs {
  _call: ExecUniOrSushiCall;

  constructor(call: ExecUniOrSushiCall) {
    this._call = call;
  }

  get _order(): ExecUniOrSushiCall_orderStruct {
    return this._call.inputValues[0].value.toTuple() as ExecUniOrSushiCall_orderStruct;
  }

  get _id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _uniswapTradePath(): Array<Address> {
    return this._call.inputValues[2].value.toAddressArray();
  }

  get isUni(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class ExecUniOrSushiCall__Outputs {
  _call: ExecUniOrSushiCall;

  constructor(call: ExecUniOrSushiCall) {
    this._call = call;
  }
}

export class ExecUniOrSushiCall_orderStruct extends ethereum.Tuple {
  get user(): Address {
    return this[0].toAddress();
  }

  get inToken(): Address {
    return this[1].toAddress();
  }

  get outToken(): Address {
    return this[2].toAddress();
  }

  get amountPerTrade(): BigInt {
    return this[3].toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this[4].toBigInt();
  }

  get minSlippage(): BigInt {
    return this[5].toBigInt();
  }

  get maxSlippage(): BigInt {
    return this[6].toBigInt();
  }

  get delay(): BigInt {
    return this[7].toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this[8].toBigInt();
  }

  get lastExecutionTime(): BigInt {
    return this[9].toBigInt();
  }
}

export class SubmitCall extends ethereum.Call {
  get inputs(): SubmitCall__Inputs {
    return new SubmitCall__Inputs(this);
  }

  get outputs(): SubmitCall__Outputs {
    return new SubmitCall__Outputs(this);
  }
}

export class SubmitCall__Inputs {
  _call: SubmitCall;

  constructor(call: SubmitCall) {
    this._call = call;
  }

  get inToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get outToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amountPerTrade(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get nTradesLeft(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get minSlippage(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get maxSlippage(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get delay(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get gasPriceCeil(): BigInt {
    return this._call.inputValues[7].value.toBigInt();
  }
}

export class SubmitCall__Outputs {
  _call: SubmitCall;

  constructor(call: SubmitCall) {
    this._call = call;
  }
}
